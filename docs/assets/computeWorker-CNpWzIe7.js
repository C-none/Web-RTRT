(function(){"use strict";class f{min=new Float32Array([1/0,1/0,1/0]);max=new Float32Array([-1/0,-1/0,-1/0]);constructor(i=new Float32Array(0),e=0){for(let t=0;t<e;t++)for(let s=0;s<3;s++)this.min[s]=Math.min(this.min[s],i[t*3+s]),this.max[s]=Math.max(this.max[s],i[t*3+s])}empty(){const i=(e,t)=>e.every((s,n)=>s==t[n]);return i(this.min,new Float32Array([1/0,1/0,1/0]))&&i(this.max,new Float32Array([-1/0,-1/0,-1/0]))}fix(){if(this.empty())return;const i=.001;for(let e=0;e<3;e++){let t=i;for(;this.max[e]-this.min[e]<t;)this.min[e]-=t,this.max[e]+=t,t*=2}}surfaceArea(){if(this.empty())return 0;const i=this.max.map((e,t)=>e-this.min[t]);return 2*(i[0]*i[1]+i[1]*i[2]+i[2]*i[0])}expand(i){this.max=this.max.map((e,t)=>Math.max(e,i.max[t])),this.min=this.min.map((e,t)=>Math.min(e,i.min[t]))}center(){return this.min.map((i,e)=>(i+this.max[e])/2)}static union(i,e){const t=new f;return t.min=i.min.map((s,n)=>Math.min(s,e.min[n])),t.max=i.max.map((s,n)=>Math.max(s,e.max[n])),t}static intersect(i,e){const t=new f;return t.min=i.min.map((s,n)=>Math.max(s,e.min[n])),t.max=i.max.map((s,n)=>Math.min(s,e.max[n])),t}}class g{vertexArray;indexArray;constructor(i,e){this.vertexArray=i,this.indexArray=e}size(){return this.indexArray.length/3}at(i){let e=new Float32Array(9);for(let t=0;t<3;t++){const s=this.indexArray[i*3+t],n=t*3;e.set(this.vertexArray.slice(s*4,s*4+3),n)}return e}}class U{index=0;aabb=new f}class T{aabb;child;is_leaf=!1;Axis=0}class M{nodes=[];maxDepth=0}class _{bvh;triangleView=[];address=0;onProgress=i=>{};constructor(i,e,t){console.log("building BVH");let s=new Date().getTime();this.onProgress=t||this.onProgress,this.bvh=i;const n=e.size();this.triangleView=new Array(n);for(let h=0;h<n;h++)this.triangleView[h]=new U,this.triangleView[h].index=h,this.triangleView[h].aabb=new f(e.at(h),3);this.bvh.nodes=new Array(2*n-1);for(let h=0;h<this.bvh.nodes.length;h++)this.bvh.nodes[h]=new T;this.address=1,this.build(0,0,n,1),console.log("BVH built time: ",(new Date().getTime()-s)/1e3,"s"),console.log("maxDepth:",this.bvh.maxDepth)}handledNodes=0;build(i,e,t,s){if(s>this.bvh.maxDepth&&(this.bvh.maxDepth=s),this.handledNodes++,this.handledNodes%Math.ceil(this.bvh.nodes.length/200)==0&&this.onProgress(this.handledNodes/this.bvh.nodes.length),t==1){this.bvh.nodes[i].aabb=this.triangleView[e].aabb,this.bvh.nodes[i].is_leaf=!0,this.bvh.nodes[i].child=this.triangleView[e].index;return}let n=this.triangleView.slice(e,e+t);const h=new f;n.forEach((m,a)=>{h.expand(m.aabb)}),this.bvh.nodes[i].aabb=h,this.bvh.nodes[i].is_leaf=!1;const B=this.address++,O=this.address++;this.bvh.nodes[i].child=B;function V(m,a,o,c){if(o-a<=1)return a;for(o--;a<o;){for(;a<o&&c(m[a]);)a++;for(;a<o&&!c(m[o]);)o--;a<o&&([m[a],m[o]]=[m[o],m[a]])}return a}const d=new f;n.forEach((m,a)=>{d.expand(new f(m.aabb.center(),1))});const x=d.max.reduce((m,a,o)=>{const c=a-d.min[o];return c>m.maxDiff?{maxIndex:o,maxDiff:c}:m},{maxIndex:-1,maxDiff:-1/0}).maxIndex;this.bvh.nodes[i].Axis=x;let b={minCostCnt:0,minCost:1/0};if(t>=16&&d.min[x]!=d.max[x]){const a=new Array(12);for(let l=0;l<12;l++)a[l]={cnt:0,aabb:new f};n.forEach((l,N)=>{let p=Math.min(Math.floor((l.aabb.center()[x]-d.min[x])/(d.max[x]-d.min[x])*12),11);a[p].cnt++,a[p].aabb.expand(l.aabb)});let o=new Array(12).fill(0),c=new Array(12).fill(0),y=0,C=0,r=new f,u=new f;for(let l=0;l<11;l++)r.expand(a[l].aabb),u.expand(a[11-l].aabb),y+=a[l].cnt,C+=a[11-l].cnt,o[l]=r.surfaceArea()*y,c[11-l]=u.surfaceArea()*C;let I=1/0,v=0;for(let l=0;l<11;l++){let N=o[l]+c[l+1];N<I&&(I=N,v=l)}I<b.minCost&&(b.minCost=I,b.minCostCnt=V(this.triangleView,e,e+t,l=>Math.min(Math.floor((l.aabb.center()[x]-d.min[x])/(d.max[x]-d.min[x])*12),11)<=v)-e)}else{n.sort((r,u)=>r.aabb.center()[x]-u.aabb.center()[x]);let m=new Array(t).fill(0),a=new Array(t).fill(0),o=new f,c=new f;for(let r=0;r<t-1;r++)o.expand(n[r].aabb),c.expand(n[t-1-r].aabb),m[r]=o.surfaceArea(),a[t-1-r]=c.surfaceArea();let y=1/0,C=0;for(let r=0;r<t-1;r++){let u=(r+1)*m[r]+(t-r-1)*a[r+1];u<y&&(y=u,C=r)}if(y<b.minCost){b.minCost=y,b.minCostCnt=C+1;for(let r=0;r<t;r++)this.triangleView[e+r]=n[r]}}this.build(B,e,b.minCostCnt,s+1),this.build(O,e+b.minCostCnt,t-b.minCostCnt,s+1)}}let A=new M;self.onmessage=async w=>{await new _(A,new g(w.data.vertexArray,w.data.indexArray),s=>{postMessage("building bvh progress: "+(s*100).toPrecision(3)+"%")});let i=new ArrayBuffer(A.nodes.length*8*4),e=new Float32Array(i),t=new Uint32Array(i);for(let s=0;s<A.nodes.length;s++){let n=A.nodes[s],h=s*8;e.set(n.aabb.min,h),t.set(new Uint32Array([(n.is_leaf?1:0)+n.Axis*2]),h+3),e.set(n.aabb.max,h+4),t.set(new Uint32Array([n.child]),h+7)}postMessage(A.maxDepth),postMessage(i,{transfer:[i]}),self.close()}})();
