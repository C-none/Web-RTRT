
@group(0) @binding(0) var<uniform> sampJitter : vec2<f32>;
@group(0) @binding(1) var samp : sampler;
@group(0) @binding(2) var rawDisplay : texture_2d<f32>;
@group(0) @binding(3) var currentDisplay : texture_storage_2d<displayFormat, write>;


// #include <FSR_common.wgsl>;
// var globalInvocationID: vec3<i32> = vec3<i32>(0, 0, 0);
// var workgroupID: vec3<i32> = vec3<i32>(0, 0, 0);
// var localInvocationID: vec3<i32> = vec3<i32>(0, 0, 0);


fn floatBitsToUint(f: f32) -> u32 {
    // 使用GLSL.std.450库中的glsl450扩展函数
    // 将浮点数转换为无符号整数
    return bitcast<u32>(f);
}
fn uintBitsToFloat(f: u32) -> f32 {
    // 使用GLSL.std.450库中的glsl450扩展函数
    // 将浮点数转换为无符号整数
    return bitcast<f32>(f);
}


fn FsrRcasInputF(r: ptr<function,f32>, g: ptr<function,f32>, b: ptr<function,f32>) {}
fn LoadRCAS_Input(p: vec2<i32>) -> vec4<f32> {
    return textureLoad(rawDisplay, p, 0);
}


fn tone_mapping(hdrColor: vec3<f32>) -> vec4<f32> {

    var mapped: vec3<f32> = vec3<f32>(1.0) - exp(-hdrColor * fExposure);

    let color: vec4<f32> = vec4<f32>(mapped, 1.0);
    return color;
}  
fn eUpscaledOutput(p: vec2<i32>, value: vec3<f32>) {
    textureStore(currentDisplay, p, tone_mapping(value));

    // textureStore(currentDisplay, p, vec4<f32>(ACESToneMapping(value, fExposure), 1));
}
fn FsrRcasLoadF(p: vec2<i32>) -> vec3<f32> {
    var fColor: vec3<f32> = LoadRCAS_Input(p).xyz;
    //fColor.xyz = PrepareRgb(fColor.xyz, Exposure(), PreExposure());
    // fColor.xyz = PrepareRgb(fColor.xyz, Exposure(), PreExposure());
    // fColor.xyz = PrepareRgb(fColor.xyz, Exposure(), PreExposure());
    //return fColor;
    return PrepareRgb(fColor.xyz, Exposure(), PreExposure());
}

fn ffxApproximateReciprocalMedium(value: f32) -> f32 {
    var b: f32 = uintBitsToFloat(u32(0x7ef19fff) - floatBitsToUint(value));
    return b * (-b * value + f32(2.0));
}
// fn FsrRcasCon()->vec4<u32> {
fn RCASConfig() -> vec4<u32> {
    // The scale is {0.0 := maximum, to N>0, where N is the number of stops (halving) of the reduction of sharpness}.
    // Transform from stops to linear value.
    var _sharpness = exp2(-fSharpness);
    var hSharp: vec2<f32> = vec2<f32>(_sharpness, _sharpness);
    var con: vec4<u32> = vec4<u32>(0, 0, 0, 0);
    con[0] = floatBitsToUint(_sharpness);
    con[1] = pack2x16float(hSharp);
    con[2] = 0;
    con[3] = 0;
    return con;
}
fn FsrRcasF(pixR: ptr<function,f32>,  // Output values, non-vector so port between RcasFilter() and RcasFilterH() is easy.
    pixG: ptr<function,f32>,
    pixB: ptr<function,f32>,
//#ifdef FSR_RCAS_PASSTHROUGH_ALPHA
//               pixA:ptr<function,f32>,
//#endif
    ip: vec2<u32>,  // Integer pixel position in output.
    _con: vec4<u32>) {  
     // Constant generated by RcasSetup().
     // Algorithm uses minimal 3x3 pixel neighborhood.
     //    b
     //  d e f
     //    h

    var con: vec4<u32> = _con;
    var sp: vec2<i32> = vec2<i32>(ip);
    var b: vec3<f32> = FsrRcasLoadF(sp + vec2<i32>(0, -1)).xyz;
    var d: vec3<f32> = FsrRcasLoadF(sp + vec2<i32>(-1, 0)).xyz;
//#ifdef FSR_RCAS_PASSTHROUGH_ALPHA
    //  var ee:vec4<f32> = FsrRcasLoadF(sp);
    //  var e :vec3<f32> = ee.xyz;
    //  *pixA            = ee.a;
// #else
    var e: vec3<f32> = FsrRcasLoadF(sp).xyz;
// #endif
    var f: vec3<f32> = FsrRcasLoadF(sp + vec2<i32>(1, 0)).xyz;
    var h: vec3<f32> = FsrRcasLoadF(sp + vec2<i32>(0, 1)).xyz;
     // Rename (32-bit) or regroup (16-bit).
    var bR: f32 = b.x;
    var bG: f32 = b.y;
    var bB: f32 = b.z;
    var dR: f32 = d.x;
    var dG: f32 = d.y;
    var dB: f32 = d.z;
    var eR: f32 = e.x;
    var eG: f32 = e.y;
    var eB: f32 = e.z;
    var fR: f32 = f.x;
    var fG: f32 = f.y;
    var fB: f32 = f.z;
    var hR: f32 = h.x;
    var hG: f32 = h.y;
    var hB: f32 = h.z;
     // Run optional input transform.
    //  FsrRcasInputF(bR, bG, bB);
    //  FsrRcasInputF(dR, dG, dB);
    //  FsrRcasInputF(eR, eG, eB);
    //  FsrRcasInputF(fR, fG, fB);
    //  FsrRcasInputF(hR, hG, hB);
     // Luma times 2.
    var bL: f32 = bB * f32(0.5) + (bR * f32(0.5) + bG);
    var dL: f32 = dB * f32(0.5) + (dR * f32(0.5) + dG);
    var eL: f32 = eB * f32(0.5) + (eR * f32(0.5) + eG);
    var fL: f32 = fB * f32(0.5) + (fR * f32(0.5) + fG);
    var hL: f32 = hB * f32(0.5) + (hR * f32(0.5) + hG);
     // Noise detection.
    var nz: f32 = f32(0.25) * bL + f32(0.25) * dL + f32(0.25) * fL + f32(0.25) * hL - eL;
    nz = Saturate(abs(nz) * ffxApproximateReciprocalMedium(max3(max3(bL, dL, eL), fL, hL) - min3(min3(bL, dL, eL), fL, hL)));
    nz = f32(-0.5) * nz + f32(1.0);
     // Min and max of ring.
    var mn4R: f32 = min(min3(bR, dR, fR), hR);
    var mn4G: f32 = min(min3(bG, dG, fG), hG);
    var mn4B: f32 = min(min3(bB, dB, fB), hB);
    var mx4R: f32 = max(max3(bR, dR, fR), hR);
    var mx4G: f32 = max(max3(bG, dG, fG), hG);
    var mx4B: f32 = max(max3(bB, dB, fB), hB);
     // Immediate constants for peak range.
    var peakC: vec2<f32> = vec2<f32>(1.0, -1.0 * 4.0);
     // Limiters, these need to be high precision RCPs.
    var hitMinR: f32 = mn4R * rcp(f32(4.0) * mx4R);
    var hitMinG: f32 = mn4G * rcp(f32(4.0) * mx4G);
    var hitMinB: f32 = mn4B * rcp(f32(4.0) * mx4B);
    var hitMaxR: f32 = (peakC.x - mx4R) * rcp(f32(4.0) * mn4R + peakC.y);
    var hitMaxG: f32 = (peakC.x - mx4G) * rcp(f32(4.0) * mn4G + peakC.y);
    var hitMaxB: f32 = (peakC.x - mx4B) * rcp(f32(4.0) * mn4B + peakC.y);
    var lobeR: f32 = max(-hitMinR, hitMaxR);
    var lobeG: f32 = max(-hitMinG, hitMaxG);
    var lobeB: f32 = max(-hitMinB, hitMaxB);
    var lobe: f32 = max(f32(-FSR_RCAS_LIMIT), min(max3(lobeR, lobeG, lobeB), f32(0.0))) * f32(con.x);
 // Apply noise removal.
//#ifdef FSR_RCAS_DENOISE
    lobe *= nz;
//#endif  {   // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.
    let rcpL: f32 = ffxApproximateReciprocalMedium(f32(4.0) * lobe + f32(1.0));
    *pixR = (lobe * bR + lobe * dR + lobe * hR + lobe * fR + eR) * rcpL;
    *pixG = (lobe * bG + lobe * dG + lobe * hG + lobe * fG + eG) * rcpL;
    *pixB = (lobe * bB + lobe * dB + lobe * hB + lobe * fB + eB) * rcpL;
    return;
}
fn CurrFilter(pos: vec2<i32>) {
    var cx: f32 = 0;
    var cy: f32 = 0;
    var cz: f32 = 0;
    FsrRcasF(&(cx), &(cy), &(cz), vec2<u32>(pos), RCASConfig());
    var c: vec3<f32> = vec3<f32>(cx, cy, cz);
    c = UnprepareRgb(c, Exposure());
    eUpscaledOutput(pos, c);
}
// fn RCAS(RLocalThreadId: vec3<u32>, WorkGroupId: vec3<u32>, Dtid: vec3<u32>) {
//     // Do remapping o local xy in workgroup for a more PS-like swizzle pattern.  
//     var gxy: vec2<i32> = ffxRemapForQuad(LocalThreadId.x) + vec2<i32>(WorkGroupId.x * 16, WorkGroupId.y * 16);
//     CurrFilter(vec2<i32>(gxy));
//     gxy.x += 8u;
//     CurrFilter(vec2<i32>(gxy));
//     gxy.y += 8u;
//     CurrFilter(vec2<i32>(gxy));
//     gxy.x -= 8u;
//     CurrFilter(vec2<i32>(gxy));
// }

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID: vec3u, @builtin(workgroup_id) WorkgroupID: vec3u, @builtin(local_invocation_id) LocalInvocationID: vec3u) {
    let screen_size: vec2<i32> = DisplaySize();
    let screen_pos: vec2<i32> = vec2<i32>(GlobalInvocationID.xy);
    // globalInvocationID = vec3<i32>(GlobalInvocationID);
    // workgroupID = vec3<i32>(WorkgroupID);
    // localInvocationID = vec3<i32>(LocalInvocationID);
    //invokePreload(vec2i(GlobalInvocationID.xy), vec2i(LocalInvocationID.xy));
    if !IsOnScreen(screen_pos, screen_size) {
        let zlinear = zNear * zFar / (zFar + 0 * (zNear - zFar));
        return;
    }
    let origin_size: vec2<i32> = RenderSize();
    let scale_ratio: f32 = f32(screen_size.x) / f32(origin_size.x);
    let origin_pos: vec2<i32> = vec2<i32>(vec2<f32>(screen_pos) / scale_ratio);

    var gxy: vec2<i32> = screen_pos;
    //textureStore(currentDisplay, screen_pos, vec4<f32>(textureLoad(rawDisplay, screen_pos, 0).xyz, 1));
    CurrFilter(vec2<i32>(gxy));
    // gxy.x += 8;
    // CurrFilter(vec2<i32>(gxy));
    // gxy.y += 8;
    // CurrFilter(vec2<i32>(gxy));
    // gxy.x -= 8;
    // CurrFilter(vec2<i32>(gxy));
} 
            